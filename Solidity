pragma solidity ^0.4.22;

contract Users{

    mapping(address => uint) records;
    mapping(string => address) receiverRecords;
    address cBddr = 0x72bA7d8E73Fe8EB666eA66babC8116A41bfb10e3;
    CommunicatorReceiver commR = new CommunicatorReceiver(cBddr);
    CommunicatorSend cSender = new CommunicatorSend(commR);

    constructor() public payable{

    }

    Sender sender = new Sender(cSender);

    Receiver receiver = new Receiver(commR);

    function createUser(string name) payable public {
        records[msg.sender] = msg.value;
        receiverRecords[name] = msg.sender;
    }

    function sendToB(address a, uint balance, string recName) payable public returns (bool){
        uint t = records[a];
        if (t < balance)
            return false;
        else{
            sender.register(a, t);
            sender.comToSend(recName, balance, a);
            uint balAfter = sender.getBalance(a);
            records[a] = balAfter;
            address reciverAd = receiverRecords[recName];
            records[reciverAd] = receiver.getBalance(recName);
        }
    }

    function registerRec(address a, string recName) payable public{
        receiver.register(a, recName, records[a]);
    }

    function getBalance(address addr) public view returns(uint){
        return records[addr];
    }
    
}

contract Sender{
    mapping(address => uint) record;
    CommunicatorSend comSend;

    constructor(CommunicatorSend cSender) public payable {
        uint amounts = 100000000;
        cSender.registerAddress(address(this), amounts);
        comSend = cSender;
    }

    function register(address a, uint balance) public{
        record[a] = balance;
    }

    function comToSend(string recName, uint balance, address input) payable public {
        comSend.requestSend(address(this), recName, balance, input);
    }

    function onSends(uint balance, bool isSuccess, address input) public{
        if(isSuccess){
            record[input] = record[input] - balance;
        }
    }

    function getBalance(address addr) public view returns(uint){
        return record[addr];
    }

}

contract CommunicatorSend{
    mapping(address => uint) managedContracts;
    CommunicatorReceiver commR;

    constructor(CommunicatorReceiver cReceiver) public payable {
        commR = cReceiver;
    }

    function requestSend(address a, string b, uint balance, address input) payable public{
        managedContracts[a] = managedContracts[a] + balance; // increase balance to the Sender, Sender pass the balance to the receiver
        if(commR.requestReceive(b, balance)){
            onSend(balance, a, true, input);
        }
    }

    function onSend(uint balance, address a, bool isSuccess, address input) payable public{
        if(isSuccess){
           //bytes4 methodId = bytes4(keccak256("onSends(uint256,bool, address)"));
            //bool flag = a.call(methodId, balance, true, input);
            //if(flag)
        //    {
         //       managedContracts[a] = managedContracts[a] - balance;
          //  }
          Sender se = Sender(a);
          se.onSends(balance,true,input);
        }
    }

    function registerAddress(address addr, uint balance) payable public{
        managedContracts[addr] = balance;
    }
}

contract CommunicatorReceiver{
    struct User{
        address addr;
        string name;
        uint amount;
    }
    address public rr;
    
    mapping(string => User) contracts;
    address public comaddress;
    address cAddr = 0x72bA7d8E73Fe8Eb666Ea66babC8116a41bFb10e2;
    CommunicatorSend commS = CommunicatorSend(cAddr);

    constructor(address input) public payable {
         comaddress = input;
    }

   function requestReceive(string b, uint balance) payable public returns(bool){
        contracts[b].amount = contracts[b].amount + balance;
        uint test = contracts[b].amount;
       // bytes4 methodId = bytes4(keccak256("onSend(uint256,address,bool,address)"));
        //if(comSender.call(methodId,balance, a, true, input)){
        Receiver re = Receiver(rr);
        re.updateBalance(b, test);
        return true;
    }

    function registerAddress(address a, string reciver, uint balance, address t) public{
        User memory user = User(a, reciver, balance);
        contracts[reciver] = user;
        rr = t;
    }
    
}

contract Receiver{
    CommunicatorReceiver cb;

    constructor(CommunicatorReceiver commR) public payable {
        cb = commR;
    }

    mapping(string => address) receiverRecords;
    mapping(string => uint) reRecords;

    function register(address a, string name, uint balance) payable public{
        receiverRecords[name] = a;
        reRecords[name] = balance;
        cb.registerAddress(a,name,balance,address(this));
    }
    
    function getBalance(string name) payable public returns(uint){
        return reRecords[name];
    }
    
     function updateBalance(string name, uint balance) payable public{
        reRecords[name] = balance;
    }

}
