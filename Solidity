pragma solidity ^0.4.22;

contract Users{
    
    struct User{
        address addr;
        string name;
        uint amount;
    }
    
    mapping(address => User) records;
    address cAddr = 0x72bA7d8E73Fe8Eb666Ea66babC8116a41bFb10e2;
    address cBddr = 0x72bA7d8E73Fe8EB666eA66babC8116A41bfb10e3;
    CommunicatorSend cSender = new CommunicatorSend(cAddr);
    CommunicatorReceiver commR = new CommunicatorReceiver(cBddr);
    
    Sender sender = new Sender(cSender);
    Receiver receiver = new Receiver();
    
    function createUser(address addr, string name, uint amount) public{
        User memory user = User(addr, name, amount);
        records[addr] = user;
    }
    
    function sendToB(address a, uint balance, string recName) public returns (bool){
        uint t = records[a].amount;
        if (t < balance) 
            return false; 
        else{
            sender.comToSend(cSender, balance, recName);
        
        }
    }
    
    function getBalance(address addr) public view returns(uint){
        return records[addr].amount;
    }
    
}

contract Sender{
    mapping(address => User) records;
    
    struct User{
        address addr;
        string name;
        uint amount;
    }
    
    constructor(CommunicatorSend cSender) public payable { 
        uint amount = 100000;
        cSender.registerAddress(address(this), amount);
    }
    
    function createUser(address addr, string name, uint amount) public payable{
        User memory user = User(addr, name, amount);
        records[addr] = user;
    }
    
    function sendToCom(uint balance, string recName) public returns(bool){
        
    }
    
    function comToSend(CommunicatorSend comm, uint balance, string recName) public payable{
        comm.requestSend(address(this), recName, balance);
    }
    
    function onSend(uint balance, address a, bool isSuccess) public{
        if(isSuccess){
            records[a].amount = records[a].amount - balance;
        }
    }
    
    function getBalance(address addr) public view returns(uint){
        return records[addr].amount;
    }
    
}

contract CommunicatorSend{
    mapping(address => uint) managedContracts;
    address public comaddress;
    
    address cBddr = 0x72bA7d8E73Fe8EB666eA66babC8116A41bfb10e3;
    CommunicatorReceiver commR = new CommunicatorReceiver(cBddr);
    
    constructor(address input) public payable { 
        comaddress = input; 
    }
    
    function requestSend(address a, string b, uint balance) public { 
        managedContracts[a] = managedContracts[a] + balance; // increase balance to the Sender, Sender pass the balance to the receiver
        commR.requestReceive(a,b, balance);    
    } 
    
    function onSend(uint balance, address a, bool isSuccess) public{
        if(isSuccess){
            bool flag = a.call("onSend", balance, a, true);
            if(flag)
            {
                managedContracts[a] = managedContracts[a] - balance;
            }
        }
    }
    
    function registerAddress(address addr, uint balance) public payable{
        managedContracts[addr] = balance;
    }
}


contract CommunicatorSend{
    mapping(address => uint) managedContracts;
    address public comaddress;
    
    address cBddr = 0x72bA7d8E73Fe8EB666eA66babC8116A41bfb10e3;
    CommunicatorReceiver commR = new CommunicatorReceiver(cBddr);
    
    constructor(address input) public payable { 
        comaddress = input; 
    }
    
    function requestSend(address a, string b, uint balance) public { 
        managedContracts[a] = managedContracts[a] + balance; // increase balance to the Sender, Sender pass the balance to the receiver
        commR.requestReceive(a,b, balance);    
    } 
    
    function onSend(uint balance, address a, bool isSuccess) public{
        if(isSuccess){
            bool flag = a.call("onSend", balance, a, true);
            if(flag)
            {
                managedContracts[a] = managedContracts[a] - balance;
            }
        }
    }
    
    function registerAddress(address addr, uint balance) public payable{
        managedContracts[addr] = balance;
    }
}

contract CommunicatorReceiver{
    mapping(address => uint) managedContracts;
    mapping(string => address) contracts;
    address public comaddress;
    address cAddr = 0x72bA7d8E73Fe8Eb666Ea66babC8116a41bFb10e2;
    CommunicatorSend commS = CommunicatorSend(cAddr);
    
    constructor(address input) public payable { 
         comaddress = input; 
    }
    
    function requestReceive(address a, string b, uint balance) public{
        if (contracts[b].call.value(balance)()) {
            commS.onSend(balance, a, true);
        }
        else{
            commS.onSend(balance, a, false);
        }
    }
    
    function registerName(string name, address addr) public payable{
        contracts[name] = addr;
    }
}

contract Receiver{
    CommunicatorReceiver cb;
    
    constructor() public payable { 
    }

    function registerContractToCommunicator() public{
        address cBddr = 0x72bA7d8E73Fe8EB666eA66babC8116A41bfb10e3;
        cb = CommunicatorReceiver(cBddr);
        cb.registerName("receiver b", address(this));
    }
}
